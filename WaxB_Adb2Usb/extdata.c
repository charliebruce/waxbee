// "Externally" defined data --
// This contains the data generated by the WaxBeeConfig tool.
//
// Data is meant to be stored in flash (program memory)
//
// The WaxBeeConfig tool will construct an allocation table.
// Each entry is identified by its "well known index". Each entry
// is four bytes and corresponds to a 16 bit PROGMEM address and a 16 bits length.
//
// The entry is treated specially if the length is 0xFFxx. In that case, the address
// field is the actual data. Valid values for "xx" is 0x00,0x01 or 0x02 which indicates
// the number of bytes "within the address field". This works well to store a flag.
//
// The 16 bits numbers must be stored as compatible endianness (see how to detect this
// below).
// The first entry points to the table itself (including that first entry). This gives out
// the table total length which could be another check.
//

#include <avr/pgmspace.h>
#include "extdata.h"

// include one of the following to run with a pre-populated config

//#include "hardcoded_extdata_intuos9x12_adb_to_graphire3.h"
//#include "hardcoded_extdata_hid_debug.h"

//==============================================================================
// Main Ext Table Location
//------------------------------------------------------------------------------
// The location of the table is decided by the configuration tool. The tool will
// modify the location of the table in the firmware. It will do so by looking-up
// a special byte sequence to identify where to store the address.
// The byte sequence includes a version number for an additional firmware check
// by the tool.
//------------------------------------------------------------------------------

struct ExtDataRoot_struct
{
	uint8_t lookupsequence[8];
	uint16_t extDataMainTable;
};

// 0x0123 constant used to verify the data is present as expected (no weird padding)
// and also to detect the current "endianness" compiler setting. This is also to
// detect that this firmware was actually "patched". If the firmware reads back that
// constant, it should refuse to run.
//
// Note: the following is intentionally not in PROGMAN (but a copy of it will be)
struct ExtDataRoot_struct extdataroot =
{
	{ 'E', 'X', 'T', '*', 'D', 'A', 'T', EXTDATA_VERSION },
#ifdef HARDCODED_EXTDATA
	(uint16_t) &hardcoded_extdata_table
#else
	EXTDATA_MAIN_TABLE_ADDRESS_PLACEHOLDER
#endif
};

//----------------------------------------------------------------------------
// Public functions
//----------------------------------------------------------------------------

/* return false on error */
bool extdata_init()
{
	if(extdataroot.extDataMainTable == EXTDATA_MAIN_TABLE_ADDRESS_PLACEHOLDER)
		return false;

	return true;
}

uint8_t	extdata_getValue8(uint8_t index)
{
	//assumption that this is stored as a "direct" value
	index *= sizeof(struct ExtData);

	return pgm_read_byte(extdataroot.extDataMainTable + index);
}

uint16_t extdata_getValue16(uint8_t index)
{
	//assumption that this is stored as a "direct" value
	index *= sizeof(struct ExtData);

	return pgm_read_word(extdataroot.extDataMainTable + index);
}

uint8_t extdata_getLength8(uint8_t index)
{
	index *= sizeof(struct ExtData);
	index += 2;

	return pgm_read_byte(extdataroot.extDataMainTable + index);
}

uint16_t extdata_getLength16(uint8_t index)
{
	index *= sizeof(struct ExtData);
	index += 2;

	uint16_t len16 = pgm_read_word(extdataroot.extDataMainTable + index);

	if((len16 & 0xFF00) == 0xFF00)
		len16 &= 0x00FF;

	return len16;
}

uint16_t extdata_getAddress(uint8_t index)
{
	index *= sizeof(struct ExtData);
	uint16_t loc = extdataroot.extDataMainTable + index;

	if(pgm_read_byte(loc + 3) == 0xFF)
		return loc; // data stored in the table directly

	return pgm_read_word(loc);
}

